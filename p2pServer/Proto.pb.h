// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto.proto

#ifndef PROTOBUF_Proto_2eproto__INCLUDED
#define PROTOBUF_Proto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Proto_2eproto();
void protobuf_AssignDesc_Proto_2eproto();
void protobuf_ShutdownFile_Proto_2eproto();

class LoginMessage;
class LogoutMessage;
class Message;
class P2PMessage;
class P2PTranslate;
class ServerToClient;
class UserListNode;

// ===================================================================

class LoginMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LoginMessage) */ {
 public:
  LoginMessage();
  virtual ~LoginMessage();

  LoginMessage(const LoginMessage& from);

  inline LoginMessage& operator=(const LoginMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginMessage& default_instance();

  void Swap(LoginMessage* other);

  // implements Message ----------------------------------------------

  inline LoginMessage* New() const { return New(NULL); }

  LoginMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginMessage& from);
  void MergeFrom(const LoginMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Proto.LoginMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static LoginMessage* default_instance_;
};
// -------------------------------------------------------------------

class LogoutMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LogoutMessage) */ {
 public:
  LogoutMessage();
  virtual ~LogoutMessage();

  LogoutMessage(const LogoutMessage& from);

  inline LogoutMessage& operator=(const LogoutMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutMessage& default_instance();

  void Swap(LogoutMessage* other);

  // implements Message ----------------------------------------------

  inline LogoutMessage* New() const { return New(NULL); }

  LogoutMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutMessage& from);
  void MergeFrom(const LogoutMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Proto.LogoutMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static LogoutMessage* default_instance_;
};
// -------------------------------------------------------------------

class P2PTranslate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.P2PTranslate) */ {
 public:
  P2PTranslate();
  virtual ~P2PTranslate();

  P2PTranslate(const P2PTranslate& from);

  inline P2PTranslate& operator=(const P2PTranslate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PTranslate& default_instance();

  void Swap(P2PTranslate* other);

  // implements Message ----------------------------------------------

  inline P2PTranslate* New() const { return New(NULL); }

  P2PTranslate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PTranslate& from);
  void MergeFrom(const P2PTranslate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(P2PTranslate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Proto.P2PTranslate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static P2PTranslate* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // optional .Proto.LoginMessage loginmember = 2;
  bool has_loginmember() const;
  void clear_loginmember();
  static const int kLoginmemberFieldNumber = 2;
  const ::Proto::LoginMessage& loginmember() const;
  ::Proto::LoginMessage* mutable_loginmember();
  ::Proto::LoginMessage* release_loginmember();
  void set_allocated_loginmember(::Proto::LoginMessage* loginmember);

  // optional .Proto.LogoutMessage logoutmember = 3;
  bool has_logoutmember() const;
  void clear_logoutmember();
  static const int kLogoutmemberFieldNumber = 3;
  const ::Proto::LogoutMessage& logoutmember() const;
  ::Proto::LogoutMessage* mutable_logoutmember();
  ::Proto::LogoutMessage* release_logoutmember();
  void set_allocated_logoutmember(::Proto::LogoutMessage* logoutmember);

  // optional .Proto.P2PTranslate translatemessage = 4;
  bool has_translatemessage() const;
  void clear_translatemessage();
  static const int kTranslatemessageFieldNumber = 4;
  const ::Proto::P2PTranslate& translatemessage() const;
  ::Proto::P2PTranslate* mutable_translatemessage();
  ::Proto::P2PTranslate* release_translatemessage();
  void set_allocated_translatemessage(::Proto::P2PTranslate* translatemessage);

  // @@protoc_insertion_point(class_scope:Proto.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Proto::LoginMessage* loginmember_;
  ::Proto::LogoutMessage* logoutmember_;
  ::Proto::P2PTranslate* translatemessage_;
  ::google::protobuf::int32 imessagetype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class UserListNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.UserListNode) */ {
 public:
  UserListNode();
  virtual ~UserListNode();

  UserListNode(const UserListNode& from);

  inline UserListNode& operator=(const UserListNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserListNode& default_instance();

  void Swap(UserListNode* other);

  // implements Message ----------------------------------------------

  inline UserListNode* New() const { return New(NULL); }

  UserListNode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserListNode& from);
  void MergeFrom(const UserListNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserListNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional uint32 ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  ::google::protobuf::uint32 ip() const;
  void set_ip(::google::protobuf::uint32 value);

  // optional uint32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.UserListNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static UserListNode* default_instance_;
};
// -------------------------------------------------------------------

class ServerToClient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.ServerToClient) */ {
 public:
  ServerToClient();
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClient& default_instance();

  void Swap(ServerToClient* other);

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const { return New(NULL); }

  ServerToClient* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerToClient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // optional .Proto.UserListNode user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::Proto::UserListNode& user() const;
  ::Proto::UserListNode* mutable_user();
  ::Proto::UserListNode* release_user();
  void set_allocated_user(::Proto::UserListNode* user);

  // @@protoc_insertion_point(class_scope:Proto.ServerToClient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Proto::UserListNode* user_;
  ::google::protobuf::int32 imessagetype_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static ServerToClient* default_instance_;
};
// -------------------------------------------------------------------

class P2PMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.P2PMessage) */ {
 public:
  P2PMessage();
  virtual ~P2PMessage();

  P2PMessage(const P2PMessage& from);

  inline P2PMessage& operator=(const P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PMessage& default_instance();

  void Swap(P2PMessage* other);

  // implements Message ----------------------------------------------

  inline P2PMessage* New() const { return New(NULL); }

  P2PMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PMessage& from);
  void MergeFrom(const P2PMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(P2PMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // optional int32 iStringLen = 2;
  void clear_istringlen();
  static const int kIStringLenFieldNumber = 2;
  ::google::protobuf::int32 istringlen() const;
  void set_istringlen(::google::protobuf::int32 value);

  // optional uint32 Port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.P2PMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 imessagetype_;
  ::google::protobuf::int32 istringlen_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Proto_2eproto();
  friend void protobuf_AssignDesc_Proto_2eproto();
  friend void protobuf_ShutdownFile_Proto_2eproto();

  void InitAsDefaultInstance();
  static P2PMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LoginMessage

// optional string userName = 1;
inline void LoginMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.userName)
}
inline void LoginMessage::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.userName)
}
inline void LoginMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.userName)
}
inline ::std::string* LoginMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.userName)
}

// optional string password = 2;
inline void LoginMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginMessage::password() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.password)
}
inline void LoginMessage::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.password)
}
inline void LoginMessage::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.password)
}
inline ::std::string* LoginMessage::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginMessage::release_password() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.password)
}

// -------------------------------------------------------------------

// LogoutMessage

// optional string userName = 1;
inline void LogoutMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogoutMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LogoutMessage.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LogoutMessage.userName)
}
inline void LogoutMessage::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LogoutMessage.userName)
}
inline void LogoutMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LogoutMessage.userName)
}
inline ::std::string* LogoutMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LogoutMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogoutMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LogoutMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LogoutMessage.userName)
}

// -------------------------------------------------------------------

// P2PTranslate

// optional string userName = 1;
inline void P2PTranslate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& P2PTranslate::username() const {
  // @@protoc_insertion_point(field_get:Proto.P2PTranslate.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void P2PTranslate::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.P2PTranslate.userName)
}
inline void P2PTranslate::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.P2PTranslate.userName)
}
inline void P2PTranslate::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.P2PTranslate.userName)
}
inline ::std::string* P2PTranslate::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.P2PTranslate.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* P2PTranslate::release_username() {
  // @@protoc_insertion_point(field_release:Proto.P2PTranslate.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void P2PTranslate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.P2PTranslate.userName)
}

// -------------------------------------------------------------------

// Message

// optional int32 iMessageType = 1;
inline void Message::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 Message::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.Message.iMessageType)
  return imessagetype_;
}
inline void Message::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Message.iMessageType)
}

// optional .Proto.LoginMessage loginmember = 2;
inline bool Message::has_loginmember() const {
  return !_is_default_instance_ && loginmember_ != NULL;
}
inline void Message::clear_loginmember() {
  if (GetArenaNoVirtual() == NULL && loginmember_ != NULL) delete loginmember_;
  loginmember_ = NULL;
}
inline const ::Proto::LoginMessage& Message::loginmember() const {
  // @@protoc_insertion_point(field_get:Proto.Message.loginmember)
  return loginmember_ != NULL ? *loginmember_ : *default_instance_->loginmember_;
}
inline ::Proto::LoginMessage* Message::mutable_loginmember() {
  
  if (loginmember_ == NULL) {
    loginmember_ = new ::Proto::LoginMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.loginmember)
  return loginmember_;
}
inline ::Proto::LoginMessage* Message::release_loginmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.loginmember)
  
  ::Proto::LoginMessage* temp = loginmember_;
  loginmember_ = NULL;
  return temp;
}
inline void Message::set_allocated_loginmember(::Proto::LoginMessage* loginmember) {
  delete loginmember_;
  loginmember_ = loginmember;
  if (loginmember) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.loginmember)
}

// optional .Proto.LogoutMessage logoutmember = 3;
inline bool Message::has_logoutmember() const {
  return !_is_default_instance_ && logoutmember_ != NULL;
}
inline void Message::clear_logoutmember() {
  if (GetArenaNoVirtual() == NULL && logoutmember_ != NULL) delete logoutmember_;
  logoutmember_ = NULL;
}
inline const ::Proto::LogoutMessage& Message::logoutmember() const {
  // @@protoc_insertion_point(field_get:Proto.Message.logoutmember)
  return logoutmember_ != NULL ? *logoutmember_ : *default_instance_->logoutmember_;
}
inline ::Proto::LogoutMessage* Message::mutable_logoutmember() {
  
  if (logoutmember_ == NULL) {
    logoutmember_ = new ::Proto::LogoutMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.logoutmember)
  return logoutmember_;
}
inline ::Proto::LogoutMessage* Message::release_logoutmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.logoutmember)
  
  ::Proto::LogoutMessage* temp = logoutmember_;
  logoutmember_ = NULL;
  return temp;
}
inline void Message::set_allocated_logoutmember(::Proto::LogoutMessage* logoutmember) {
  delete logoutmember_;
  logoutmember_ = logoutmember;
  if (logoutmember) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.logoutmember)
}

// optional .Proto.P2PTranslate translatemessage = 4;
inline bool Message::has_translatemessage() const {
  return !_is_default_instance_ && translatemessage_ != NULL;
}
inline void Message::clear_translatemessage() {
  if (GetArenaNoVirtual() == NULL && translatemessage_ != NULL) delete translatemessage_;
  translatemessage_ = NULL;
}
inline const ::Proto::P2PTranslate& Message::translatemessage() const {
  // @@protoc_insertion_point(field_get:Proto.Message.translatemessage)
  return translatemessage_ != NULL ? *translatemessage_ : *default_instance_->translatemessage_;
}
inline ::Proto::P2PTranslate* Message::mutable_translatemessage() {
  
  if (translatemessage_ == NULL) {
    translatemessage_ = new ::Proto::P2PTranslate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.translatemessage)
  return translatemessage_;
}
inline ::Proto::P2PTranslate* Message::release_translatemessage() {
  // @@protoc_insertion_point(field_release:Proto.Message.translatemessage)
  
  ::Proto::P2PTranslate* temp = translatemessage_;
  translatemessage_ = NULL;
  return temp;
}
inline void Message::set_allocated_translatemessage(::Proto::P2PTranslate* translatemessage) {
  delete translatemessage_;
  translatemessage_ = translatemessage;
  if (translatemessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.translatemessage)
}

// -------------------------------------------------------------------

// UserListNode

// optional string userName = 1;
inline void UserListNode::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserListNode::username() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserListNode::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.UserListNode.userName)
}
inline void UserListNode::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.UserListNode.userName)
}
inline void UserListNode::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.UserListNode.userName)
}
inline ::std::string* UserListNode::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.UserListNode.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserListNode::release_username() {
  // @@protoc_insertion_point(field_release:Proto.UserListNode.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserListNode::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.UserListNode.userName)
}

// optional uint32 ip = 2;
inline void UserListNode::clear_ip() {
  ip_ = 0u;
}
inline ::google::protobuf::uint32 UserListNode::ip() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.ip)
  return ip_;
}
inline void UserListNode::set_ip(::google::protobuf::uint32 value) {
  
  ip_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.ip)
}

// optional uint32 port = 3;
inline void UserListNode::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 UserListNode::port() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.port)
  return port_;
}
inline void UserListNode::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.port)
}

// -------------------------------------------------------------------

// ServerToClient

// optional int32 iMessageType = 1;
inline void ServerToClient::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 ServerToClient::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.iMessageType)
  return imessagetype_;
}
inline void ServerToClient::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.ServerToClient.iMessageType)
}

// optional .Proto.UserListNode user = 2;
inline bool ServerToClient::has_user() const {
  return !_is_default_instance_ && user_ != NULL;
}
inline void ServerToClient::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::Proto::UserListNode& ServerToClient::user() const {
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.user)
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::Proto::UserListNode* ServerToClient::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::Proto::UserListNode;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerToClient.user)
  return user_;
}
inline ::Proto::UserListNode* ServerToClient::release_user() {
  // @@protoc_insertion_point(field_release:Proto.ServerToClient.user)
  
  ::Proto::UserListNode* temp = user_;
  user_ = NULL;
  return temp;
}
inline void ServerToClient::set_allocated_user(::Proto::UserListNode* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerToClient.user)
}

// -------------------------------------------------------------------

// P2PMessage

// optional int32 iMessageType = 1;
inline void P2PMessage::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 P2PMessage::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iMessageType)
  return imessagetype_;
}
inline void P2PMessage::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iMessageType)
}

// optional int32 iStringLen = 2;
inline void P2PMessage::clear_istringlen() {
  istringlen_ = 0;
}
inline ::google::protobuf::int32 P2PMessage::istringlen() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iStringLen)
  return istringlen_;
}
inline void P2PMessage::set_istringlen(::google::protobuf::int32 value) {
  
  istringlen_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iStringLen)
}

// optional uint32 Port = 3;
inline void P2PMessage::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 P2PMessage::port() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.Port)
  return port_;
}
inline void P2PMessage::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.Port)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Proto_2eproto__INCLUDED
