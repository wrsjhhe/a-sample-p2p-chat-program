// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Proto.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Proto {

namespace {

const ::google::protobuf::Descriptor* LoginMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogoutMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogoutMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PTranslate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PTranslate_reflection_ = NULL;
const ::google::protobuf::Descriptor* Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_reflection_ = NULL;
const ::google::protobuf::Descriptor* UserListNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UserListNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServerToClient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServerToClient_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PMessage_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Proto_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_Proto_2eproto() {
  protobuf_AddDesc_Proto_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Proto.proto");
  GOOGLE_CHECK(file != NULL);
  LoginMessage_descriptor_ = file->message_type(0);
  static const int LoginMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginMessage, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginMessage, password_),
  };
  LoginMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LoginMessage_descriptor_,
      LoginMessage::default_instance_,
      LoginMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(LoginMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginMessage, _is_default_instance_));
  LogoutMessage_descriptor_ = file->message_type(1);
  static const int LogoutMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutMessage, username_),
  };
  LogoutMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LogoutMessage_descriptor_,
      LogoutMessage::default_instance_,
      LogoutMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(LogoutMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutMessage, _is_default_instance_));
  P2PTranslate_descriptor_ = file->message_type(2);
  static const int P2PTranslate_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PTranslate, username_),
  };
  P2PTranslate_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      P2PTranslate_descriptor_,
      P2PTranslate::default_instance_,
      P2PTranslate_offsets_,
      -1,
      -1,
      -1,
      sizeof(P2PTranslate),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PTranslate, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PTranslate, _is_default_instance_));
  Message_descriptor_ = file->message_type(3);
  static const int Message_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, imessagetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, loginmember_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, logoutmember_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, translatemessage_),
  };
  Message_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Message_descriptor_,
      Message::default_instance_,
      Message_offsets_,
      -1,
      -1,
      -1,
      sizeof(Message),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _is_default_instance_));
  UserListNode_descriptor_ = file->message_type(4);
  static const int UserListNode_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserListNode, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserListNode, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserListNode, port_),
  };
  UserListNode_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      UserListNode_descriptor_,
      UserListNode::default_instance_,
      UserListNode_offsets_,
      -1,
      -1,
      -1,
      sizeof(UserListNode),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserListNode, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UserListNode, _is_default_instance_));
  ServerToClient_descriptor_ = file->message_type(5);
  static const int ServerToClient_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, imessagetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, user_),
  };
  ServerToClient_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ServerToClient_descriptor_,
      ServerToClient::default_instance_,
      ServerToClient_offsets_,
      -1,
      -1,
      -1,
      sizeof(ServerToClient),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerToClient, _is_default_instance_));
  P2PMessage_descriptor_ = file->message_type(6);
  static const int P2PMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PMessage, imessagetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PMessage, istringlen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PMessage, port_),
  };
  P2PMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      P2PMessage_descriptor_,
      P2PMessage::default_instance_,
      P2PMessage_offsets_,
      -1,
      -1,
      -1,
      sizeof(P2PMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PMessage, _is_default_instance_));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Proto_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LoginMessage_descriptor_, &LoginMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LogoutMessage_descriptor_, &LogoutMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      P2PTranslate_descriptor_, &P2PTranslate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Message_descriptor_, &Message::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      UserListNode_descriptor_, &UserListNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ServerToClient_descriptor_, &ServerToClient::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      P2PMessage_descriptor_, &P2PMessage::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Proto_2eproto() {
  delete LoginMessage::default_instance_;
  delete LoginMessage_reflection_;
  delete LogoutMessage::default_instance_;
  delete LogoutMessage_reflection_;
  delete P2PTranslate::default_instance_;
  delete P2PTranslate_reflection_;
  delete Message::default_instance_;
  delete Message_reflection_;
  delete UserListNode::default_instance_;
  delete UserListNode_reflection_;
  delete ServerToClient::default_instance_;
  delete ServerToClient_reflection_;
  delete P2PMessage::default_instance_;
  delete P2PMessage_reflection_;
}

void protobuf_AddDesc_Proto_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_Proto_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013Proto.proto\022\005Proto\"2\n\014LoginMessage\022\020\n\010"
    "userName\030\001 \001(\t\022\020\n\010password\030\002 \001(\t\"!\n\rLogo"
    "utMessage\022\020\n\010userName\030\001 \001(\t\" \n\014P2PTransl"
    "ate\022\020\n\010userName\030\001 \001(\t\"\244\001\n\007Message\022\024\n\014iMe"
    "ssageType\030\001 \001(\005\022(\n\013loginmember\030\002 \001(\0132\023.P"
    "roto.LoginMessage\022*\n\014logoutmember\030\003 \001(\0132"
    "\024.Proto.LogoutMessage\022-\n\020translatemessag"
    "e\030\004 \001(\0132\023.Proto.P2PTranslate\":\n\014UserList"
    "Node\022\020\n\010userName\030\001 \001(\t\022\n\n\002ip\030\002 \001(\r\022\014\n\004po"
    "rt\030\003 \001(\r\"I\n\016ServerToClient\022\024\n\014iMessageTy"
    "pe\030\001 \001(\005\022!\n\004user\030\002 \001(\0132\023.Proto.UserListN"
    "ode\"D\n\nP2PMessage\022\024\n\014iMessageType\030\001 \001(\005\022"
    "\022\n\niStringLen\030\002 \001(\005\022\014\n\004Port\030\003 \001(\rb\006proto"
    "3", 521);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Proto.proto", &protobuf_RegisterTypes);
  LoginMessage::default_instance_ = new LoginMessage();
  LogoutMessage::default_instance_ = new LogoutMessage();
  P2PTranslate::default_instance_ = new P2PTranslate();
  Message::default_instance_ = new Message();
  UserListNode::default_instance_ = new UserListNode();
  ServerToClient::default_instance_ = new ServerToClient();
  P2PMessage::default_instance_ = new P2PMessage();
  LoginMessage::default_instance_->InitAsDefaultInstance();
  LogoutMessage::default_instance_->InitAsDefaultInstance();
  P2PTranslate::default_instance_->InitAsDefaultInstance();
  Message::default_instance_->InitAsDefaultInstance();
  UserListNode::default_instance_->InitAsDefaultInstance();
  ServerToClient::default_instance_->InitAsDefaultInstance();
  P2PMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Proto_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Proto_2eproto {
  StaticDescriptorInitializer_Proto_2eproto() {
    protobuf_AddDesc_Proto_2eproto();
  }
} static_descriptor_initializer_Proto_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LoginMessage::kUserNameFieldNumber;
const int LoginMessage::kPasswordFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LoginMessage::LoginMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.LoginMessage)
}

void LoginMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

LoginMessage::LoginMessage(const LoginMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.LoginMessage)
}

void LoginMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

LoginMessage::~LoginMessage() {
  // @@protoc_insertion_point(destructor:Proto.LoginMessage)
  SharedDtor();
}

void LoginMessage::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void LoginMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginMessage_descriptor_;
}

const LoginMessage& LoginMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

LoginMessage* LoginMessage::default_instance_ = NULL;

LoginMessage* LoginMessage::New(::google::protobuf::Arena* arena) const {
  LoginMessage* n = new LoginMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LoginMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.LoginMessage)
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LoginMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.LoginMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Proto.LoginMessage.userName"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // optional string password = 2;
      case 2: {
        if (tag == 18) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Proto.LoginMessage.password"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.LoginMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.LoginMessage)
  return false;
#undef DO_
}

void LoginMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.LoginMessage)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LoginMessage.userName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->username(), output);
  }

  // optional string password = 2;
  if (this->password().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LoginMessage.password");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.LoginMessage)
}

::google::protobuf::uint8* LoginMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.LoginMessage)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LoginMessage.userName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // optional string password = 2;
  if (this->password().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LoginMessage.password");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.LoginMessage)
  return target;
}

int LoginMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.LoginMessage)
  int total_size = 0;

  // optional string userName = 1;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  // optional string password = 2;
  if (this->password().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.LoginMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LoginMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LoginMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.LoginMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.LoginMessage)
    MergeFrom(*source);
  }
}

void LoginMessage::MergeFrom(const LoginMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.LoginMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  if (from.password().size() > 0) {

    password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
}

void LoginMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.LoginMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginMessage::CopyFrom(const LoginMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.LoginMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginMessage::IsInitialized() const {

  return true;
}

void LoginMessage::Swap(LoginMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LoginMessage::InternalSwap(LoginMessage* other) {
  username_.Swap(&other->username_);
  password_.Swap(&other->password_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LoginMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginMessage_descriptor_;
  metadata.reflection = LoginMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LoginMessage

// optional string userName = 1;
void LoginMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& LoginMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LoginMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.userName)
}
 void LoginMessage::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.userName)
}
 void LoginMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.userName)
}
 ::std::string* LoginMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LoginMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LoginMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.userName)
}

// optional string password = 2;
void LoginMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& LoginMessage::password() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LoginMessage::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.password)
}
 void LoginMessage::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.password)
}
 void LoginMessage::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.password)
}
 ::std::string* LoginMessage::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LoginMessage::release_password() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LoginMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.password)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LogoutMessage::kUserNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LogoutMessage::LogoutMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.LogoutMessage)
}

void LogoutMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

LogoutMessage::LogoutMessage(const LogoutMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.LogoutMessage)
}

void LogoutMessage::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

LogoutMessage::~LogoutMessage() {
  // @@protoc_insertion_point(destructor:Proto.LogoutMessage)
  SharedDtor();
}

void LogoutMessage::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void LogoutMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogoutMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogoutMessage_descriptor_;
}

const LogoutMessage& LogoutMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

LogoutMessage* LogoutMessage::default_instance_ = NULL;

LogoutMessage* LogoutMessage::New(::google::protobuf::Arena* arena) const {
  LogoutMessage* n = new LogoutMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LogoutMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.LogoutMessage)
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LogoutMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.LogoutMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Proto.LogoutMessage.userName"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.LogoutMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.LogoutMessage)
  return false;
#undef DO_
}

void LogoutMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.LogoutMessage)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LogoutMessage.userName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->username(), output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.LogoutMessage)
}

::google::protobuf::uint8* LogoutMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.LogoutMessage)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.LogoutMessage.userName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.LogoutMessage)
  return target;
}

int LogoutMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.LogoutMessage)
  int total_size = 0;

  // optional string userName = 1;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogoutMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.LogoutMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LogoutMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LogoutMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.LogoutMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.LogoutMessage)
    MergeFrom(*source);
  }
}

void LogoutMessage::MergeFrom(const LogoutMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.LogoutMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
}

void LogoutMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.LogoutMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogoutMessage::CopyFrom(const LogoutMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.LogoutMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutMessage::IsInitialized() const {

  return true;
}

void LogoutMessage::Swap(LogoutMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LogoutMessage::InternalSwap(LogoutMessage* other) {
  username_.Swap(&other->username_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LogoutMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogoutMessage_descriptor_;
  metadata.reflection = LogoutMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LogoutMessage

// optional string userName = 1;
void LogoutMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& LogoutMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LogoutMessage.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LogoutMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LogoutMessage.userName)
}
 void LogoutMessage::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LogoutMessage.userName)
}
 void LogoutMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LogoutMessage.userName)
}
 ::std::string* LogoutMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LogoutMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* LogoutMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LogoutMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void LogoutMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LogoutMessage.userName)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int P2PTranslate::kUserNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

P2PTranslate::P2PTranslate()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.P2PTranslate)
}

void P2PTranslate::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

P2PTranslate::P2PTranslate(const P2PTranslate& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.P2PTranslate)
}

void P2PTranslate::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

P2PTranslate::~P2PTranslate() {
  // @@protoc_insertion_point(destructor:Proto.P2PTranslate)
  SharedDtor();
}

void P2PTranslate::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void P2PTranslate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PTranslate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PTranslate_descriptor_;
}

const P2PTranslate& P2PTranslate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

P2PTranslate* P2PTranslate::default_instance_ = NULL;

P2PTranslate* P2PTranslate::New(::google::protobuf::Arena* arena) const {
  P2PTranslate* n = new P2PTranslate;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void P2PTranslate::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.P2PTranslate)
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool P2PTranslate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.P2PTranslate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Proto.P2PTranslate.userName"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.P2PTranslate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.P2PTranslate)
  return false;
#undef DO_
}

void P2PTranslate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.P2PTranslate)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.P2PTranslate.userName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->username(), output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.P2PTranslate)
}

::google::protobuf::uint8* P2PTranslate::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.P2PTranslate)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.P2PTranslate.userName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.P2PTranslate)
  return target;
}

int P2PTranslate::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.P2PTranslate)
  int total_size = 0;

  // optional string userName = 1;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PTranslate::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.P2PTranslate)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const P2PTranslate* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const P2PTranslate>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.P2PTranslate)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.P2PTranslate)
    MergeFrom(*source);
  }
}

void P2PTranslate::MergeFrom(const P2PTranslate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.P2PTranslate)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
}

void P2PTranslate::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.P2PTranslate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PTranslate::CopyFrom(const P2PTranslate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.P2PTranslate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PTranslate::IsInitialized() const {

  return true;
}

void P2PTranslate::Swap(P2PTranslate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void P2PTranslate::InternalSwap(P2PTranslate* other) {
  username_.Swap(&other->username_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata P2PTranslate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PTranslate_descriptor_;
  metadata.reflection = P2PTranslate_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// P2PTranslate

// optional string userName = 1;
void P2PTranslate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& P2PTranslate::username() const {
  // @@protoc_insertion_point(field_get:Proto.P2PTranslate.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void P2PTranslate::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.P2PTranslate.userName)
}
 void P2PTranslate::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.P2PTranslate.userName)
}
 void P2PTranslate::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.P2PTranslate.userName)
}
 ::std::string* P2PTranslate::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.P2PTranslate.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* P2PTranslate::release_username() {
  // @@protoc_insertion_point(field_release:Proto.P2PTranslate.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void P2PTranslate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.P2PTranslate.userName)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Message::kIMessageTypeFieldNumber;
const int Message::kLoginmemberFieldNumber;
const int Message::kLogoutmemberFieldNumber;
const int Message::kTranslatemessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Message::Message()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.Message)
}

void Message::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  loginmember_ = const_cast< ::Proto::LoginMessage*>(&::Proto::LoginMessage::default_instance());
  logoutmember_ = const_cast< ::Proto::LogoutMessage*>(&::Proto::LogoutMessage::default_instance());
  translatemessage_ = const_cast< ::Proto::P2PTranslate*>(&::Proto::P2PTranslate::default_instance());
}

Message::Message(const Message& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.Message)
}

void Message::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  imessagetype_ = 0;
  loginmember_ = NULL;
  logoutmember_ = NULL;
  translatemessage_ = NULL;
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:Proto.Message)
  SharedDtor();
}

void Message::SharedDtor() {
  if (this != default_instance_) {
    delete loginmember_;
    delete logoutmember_;
    delete translatemessage_;
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_descriptor_;
}

const Message& Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

Message* Message::default_instance_ = NULL;

Message* Message::New(::google::protobuf::Arena* arena) const {
  Message* n = new Message;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.Message)
  imessagetype_ = 0;
  if (GetArenaNoVirtual() == NULL && loginmember_ != NULL) delete loginmember_;
  loginmember_ = NULL;
  if (GetArenaNoVirtual() == NULL && logoutmember_ != NULL) delete logoutmember_;
  logoutmember_ = NULL;
  if (GetArenaNoVirtual() == NULL && translatemessage_ != NULL) delete translatemessage_;
  translatemessage_ = NULL;
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 iMessageType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &imessagetype_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loginmember;
        break;
      }

      // optional .Proto.LoginMessage loginmember = 2;
      case 2: {
        if (tag == 18) {
         parse_loginmember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loginmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_logoutmember;
        break;
      }

      // optional .Proto.LogoutMessage logoutmember = 3;
      case 3: {
        if (tag == 26) {
         parse_logoutmember:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logoutmember()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_translatemessage;
        break;
      }

      // optional .Proto.P2PTranslate translatemessage = 4;
      case 4: {
        if (tag == 34) {
         parse_translatemessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_translatemessage()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.Message)
  return false;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.Message)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->imessagetype(), output);
  }

  // optional .Proto.LoginMessage loginmember = 2;
  if (this->has_loginmember()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->loginmember_, output);
  }

  // optional .Proto.LogoutMessage logoutmember = 3;
  if (this->has_logoutmember()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->logoutmember_, output);
  }

  // optional .Proto.P2PTranslate translatemessage = 4;
  if (this->has_translatemessage()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->translatemessage_, output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.Message)
}

::google::protobuf::uint8* Message::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.Message)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->imessagetype(), target);
  }

  // optional .Proto.LoginMessage loginmember = 2;
  if (this->has_loginmember()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->loginmember_, false, target);
  }

  // optional .Proto.LogoutMessage logoutmember = 3;
  if (this->has_logoutmember()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->logoutmember_, false, target);
  }

  // optional .Proto.P2PTranslate translatemessage = 4;
  if (this->has_translatemessage()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->translatemessage_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.Message)
  return target;
}

int Message::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.Message)
  int total_size = 0;

  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->imessagetype());
  }

  // optional .Proto.LoginMessage loginmember = 2;
  if (this->has_loginmember()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->loginmember_);
  }

  // optional .Proto.LogoutMessage logoutmember = 3;
  if (this->has_logoutmember()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->logoutmember_);
  }

  // optional .Proto.P2PTranslate translatemessage = 4;
  if (this->has_translatemessage()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->translatemessage_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.Message)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Message* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Message>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.Message)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.Message)
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.Message)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.imessagetype() != 0) {
    set_imessagetype(from.imessagetype());
  }
  if (from.has_loginmember()) {
    mutable_loginmember()->::Proto::LoginMessage::MergeFrom(from.loginmember());
  }
  if (from.has_logoutmember()) {
    mutable_logoutmember()->::Proto::LogoutMessage::MergeFrom(from.logoutmember());
  }
  if (from.has_translatemessage()) {
    mutable_translatemessage()->::Proto::P2PTranslate::MergeFrom(from.translatemessage());
  }
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {

  return true;
}

void Message::Swap(Message* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Message::InternalSwap(Message* other) {
  std::swap(imessagetype_, other->imessagetype_);
  std::swap(loginmember_, other->loginmember_);
  std::swap(logoutmember_, other->logoutmember_);
  std::swap(translatemessage_, other->translatemessage_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_descriptor_;
  metadata.reflection = Message_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Message

// optional int32 iMessageType = 1;
void Message::clear_imessagetype() {
  imessagetype_ = 0;
}
 ::google::protobuf::int32 Message::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.Message.iMessageType)
  return imessagetype_;
}
 void Message::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Message.iMessageType)
}

// optional .Proto.LoginMessage loginmember = 2;
bool Message::has_loginmember() const {
  return !_is_default_instance_ && loginmember_ != NULL;
}
void Message::clear_loginmember() {
  if (GetArenaNoVirtual() == NULL && loginmember_ != NULL) delete loginmember_;
  loginmember_ = NULL;
}
const ::Proto::LoginMessage& Message::loginmember() const {
  // @@protoc_insertion_point(field_get:Proto.Message.loginmember)
  return loginmember_ != NULL ? *loginmember_ : *default_instance_->loginmember_;
}
::Proto::LoginMessage* Message::mutable_loginmember() {
  
  if (loginmember_ == NULL) {
    loginmember_ = new ::Proto::LoginMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.loginmember)
  return loginmember_;
}
::Proto::LoginMessage* Message::release_loginmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.loginmember)
  
  ::Proto::LoginMessage* temp = loginmember_;
  loginmember_ = NULL;
  return temp;
}
void Message::set_allocated_loginmember(::Proto::LoginMessage* loginmember) {
  delete loginmember_;
  loginmember_ = loginmember;
  if (loginmember) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.loginmember)
}

// optional .Proto.LogoutMessage logoutmember = 3;
bool Message::has_logoutmember() const {
  return !_is_default_instance_ && logoutmember_ != NULL;
}
void Message::clear_logoutmember() {
  if (GetArenaNoVirtual() == NULL && logoutmember_ != NULL) delete logoutmember_;
  logoutmember_ = NULL;
}
const ::Proto::LogoutMessage& Message::logoutmember() const {
  // @@protoc_insertion_point(field_get:Proto.Message.logoutmember)
  return logoutmember_ != NULL ? *logoutmember_ : *default_instance_->logoutmember_;
}
::Proto::LogoutMessage* Message::mutable_logoutmember() {
  
  if (logoutmember_ == NULL) {
    logoutmember_ = new ::Proto::LogoutMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.logoutmember)
  return logoutmember_;
}
::Proto::LogoutMessage* Message::release_logoutmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.logoutmember)
  
  ::Proto::LogoutMessage* temp = logoutmember_;
  logoutmember_ = NULL;
  return temp;
}
void Message::set_allocated_logoutmember(::Proto::LogoutMessage* logoutmember) {
  delete logoutmember_;
  logoutmember_ = logoutmember;
  if (logoutmember) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.logoutmember)
}

// optional .Proto.P2PTranslate translatemessage = 4;
bool Message::has_translatemessage() const {
  return !_is_default_instance_ && translatemessage_ != NULL;
}
void Message::clear_translatemessage() {
  if (GetArenaNoVirtual() == NULL && translatemessage_ != NULL) delete translatemessage_;
  translatemessage_ = NULL;
}
const ::Proto::P2PTranslate& Message::translatemessage() const {
  // @@protoc_insertion_point(field_get:Proto.Message.translatemessage)
  return translatemessage_ != NULL ? *translatemessage_ : *default_instance_->translatemessage_;
}
::Proto::P2PTranslate* Message::mutable_translatemessage() {
  
  if (translatemessage_ == NULL) {
    translatemessage_ = new ::Proto::P2PTranslate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.translatemessage)
  return translatemessage_;
}
::Proto::P2PTranslate* Message::release_translatemessage() {
  // @@protoc_insertion_point(field_release:Proto.Message.translatemessage)
  
  ::Proto::P2PTranslate* temp = translatemessage_;
  translatemessage_ = NULL;
  return temp;
}
void Message::set_allocated_translatemessage(::Proto::P2PTranslate* translatemessage) {
  delete translatemessage_;
  translatemessage_ = translatemessage;
  if (translatemessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.translatemessage)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UserListNode::kUserNameFieldNumber;
const int UserListNode::kIpFieldNumber;
const int UserListNode::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UserListNode::UserListNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.UserListNode)
}

void UserListNode::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

UserListNode::UserListNode(const UserListNode& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.UserListNode)
}

void UserListNode::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  username_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = 0u;
  port_ = 0u;
}

UserListNode::~UserListNode() {
  // @@protoc_insertion_point(destructor:Proto.UserListNode)
  SharedDtor();
}

void UserListNode::SharedDtor() {
  username_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void UserListNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UserListNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UserListNode_descriptor_;
}

const UserListNode& UserListNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

UserListNode* UserListNode::default_instance_ = NULL;

UserListNode* UserListNode::New(::google::protobuf::Arena* arena) const {
  UserListNode* n = new UserListNode;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UserListNode::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.UserListNode)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(UserListNode, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<UserListNode*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(ip_, port_);
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool UserListNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.UserListNode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string userName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Proto.UserListNode.userName"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ip;
        break;
      }

      // optional uint32 ip = 2;
      case 2: {
        if (tag == 16) {
         parse_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ip_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional uint32 port = 3;
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.UserListNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.UserListNode)
  return false;
#undef DO_
}

void UserListNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.UserListNode)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.UserListNode.userName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->username(), output);
  }

  // optional uint32 ip = 2;
  if (this->ip() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ip(), output);
  }

  // optional uint32 port = 3;
  if (this->port() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.UserListNode)
}

::google::protobuf::uint8* UserListNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.UserListNode)
  // optional string userName = 1;
  if (this->username().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Proto.UserListNode.userName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // optional uint32 ip = 2;
  if (this->ip() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ip(), target);
  }

  // optional uint32 port = 3;
  if (this->port() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->port(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.UserListNode)
  return target;
}

int UserListNode::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.UserListNode)
  int total_size = 0;

  // optional string userName = 1;
  if (this->username().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->username());
  }

  // optional uint32 ip = 2;
  if (this->ip() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ip());
  }

  // optional uint32 port = 3;
  if (this->port() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserListNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.UserListNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const UserListNode* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const UserListNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.UserListNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.UserListNode)
    MergeFrom(*source);
  }
}

void UserListNode::MergeFrom(const UserListNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.UserListNode)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.username().size() > 0) {

    username_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.username_);
  }
  if (from.ip() != 0) {
    set_ip(from.ip());
  }
  if (from.port() != 0) {
    set_port(from.port());
  }
}

void UserListNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.UserListNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserListNode::CopyFrom(const UserListNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.UserListNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserListNode::IsInitialized() const {

  return true;
}

void UserListNode::Swap(UserListNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UserListNode::InternalSwap(UserListNode* other) {
  username_.Swap(&other->username_);
  std::swap(ip_, other->ip_);
  std::swap(port_, other->port_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UserListNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UserListNode_descriptor_;
  metadata.reflection = UserListNode_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UserListNode

// optional string userName = 1;
void UserListNode::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& UserListNode::username() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void UserListNode::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.UserListNode.userName)
}
 void UserListNode::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.UserListNode.userName)
}
 void UserListNode::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.UserListNode.userName)
}
 ::std::string* UserListNode::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.UserListNode.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* UserListNode::release_username() {
  // @@protoc_insertion_point(field_release:Proto.UserListNode.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void UserListNode::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.UserListNode.userName)
}

// optional uint32 ip = 2;
void UserListNode::clear_ip() {
  ip_ = 0u;
}
 ::google::protobuf::uint32 UserListNode::ip() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.ip)
  return ip_;
}
 void UserListNode::set_ip(::google::protobuf::uint32 value) {
  
  ip_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.ip)
}

// optional uint32 port = 3;
void UserListNode::clear_port() {
  port_ = 0u;
}
 ::google::protobuf::uint32 UserListNode::port() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.port)
  return port_;
}
 void UserListNode::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServerToClient::kIMessageTypeFieldNumber;
const int ServerToClient::kUserFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ServerToClient::ServerToClient()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.ServerToClient)
}

void ServerToClient::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  user_ = const_cast< ::Proto::UserListNode*>(&::Proto::UserListNode::default_instance());
}

ServerToClient::ServerToClient(const ServerToClient& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.ServerToClient)
}

void ServerToClient::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  imessagetype_ = 0;
  user_ = NULL;
}

ServerToClient::~ServerToClient() {
  // @@protoc_insertion_point(destructor:Proto.ServerToClient)
  SharedDtor();
}

void ServerToClient::SharedDtor() {
  if (this != default_instance_) {
    delete user_;
  }
}

void ServerToClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServerToClient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServerToClient_descriptor_;
}

const ServerToClient& ServerToClient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

ServerToClient* ServerToClient::default_instance_ = NULL;

ServerToClient* ServerToClient::New(::google::protobuf::Arena* arena) const {
  ServerToClient* n = new ServerToClient;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ServerToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.ServerToClient)
  imessagetype_ = 0;
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}

bool ServerToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.ServerToClient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 iMessageType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &imessagetype_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_user;
        break;
      }

      // optional .Proto.UserListNode user = 2;
      case 2: {
        if (tag == 18) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_user()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.ServerToClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.ServerToClient)
  return false;
#undef DO_
}

void ServerToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.ServerToClient)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->imessagetype(), output);
  }

  // optional .Proto.UserListNode user = 2;
  if (this->has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->user_, output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.ServerToClient)
}

::google::protobuf::uint8* ServerToClient::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.ServerToClient)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->imessagetype(), target);
  }

  // optional .Proto.UserListNode user = 2;
  if (this->has_user()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->user_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.ServerToClient)
  return target;
}

int ServerToClient::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.ServerToClient)
  int total_size = 0;

  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->imessagetype());
  }

  // optional .Proto.UserListNode user = 2;
  if (this->has_user()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->user_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerToClient::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.ServerToClient)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ServerToClient* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ServerToClient>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.ServerToClient)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.ServerToClient)
    MergeFrom(*source);
  }
}

void ServerToClient::MergeFrom(const ServerToClient& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.ServerToClient)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.imessagetype() != 0) {
    set_imessagetype(from.imessagetype());
  }
  if (from.has_user()) {
    mutable_user()->::Proto::UserListNode::MergeFrom(from.user());
  }
}

void ServerToClient::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.ServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServerToClient::CopyFrom(const ServerToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.ServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerToClient::IsInitialized() const {

  return true;
}

void ServerToClient::Swap(ServerToClient* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ServerToClient::InternalSwap(ServerToClient* other) {
  std::swap(imessagetype_, other->imessagetype_);
  std::swap(user_, other->user_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ServerToClient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServerToClient_descriptor_;
  metadata.reflection = ServerToClient_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ServerToClient

// optional int32 iMessageType = 1;
void ServerToClient::clear_imessagetype() {
  imessagetype_ = 0;
}
 ::google::protobuf::int32 ServerToClient::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.iMessageType)
  return imessagetype_;
}
 void ServerToClient::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.ServerToClient.iMessageType)
}

// optional .Proto.UserListNode user = 2;
bool ServerToClient::has_user() const {
  return !_is_default_instance_ && user_ != NULL;
}
void ServerToClient::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
const ::Proto::UserListNode& ServerToClient::user() const {
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.user)
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
::Proto::UserListNode* ServerToClient::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::Proto::UserListNode;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerToClient.user)
  return user_;
}
::Proto::UserListNode* ServerToClient::release_user() {
  // @@protoc_insertion_point(field_release:Proto.ServerToClient.user)
  
  ::Proto::UserListNode* temp = user_;
  user_ = NULL;
  return temp;
}
void ServerToClient::set_allocated_user(::Proto::UserListNode* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerToClient.user)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int P2PMessage::kIMessageTypeFieldNumber;
const int P2PMessage::kIStringLenFieldNumber;
const int P2PMessage::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

P2PMessage::P2PMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Proto.P2PMessage)
}

void P2PMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

P2PMessage::P2PMessage(const P2PMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Proto.P2PMessage)
}

void P2PMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  imessagetype_ = 0;
  istringlen_ = 0;
  port_ = 0u;
}

P2PMessage::~P2PMessage() {
  // @@protoc_insertion_point(destructor:Proto.P2PMessage)
  SharedDtor();
}

void P2PMessage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void P2PMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PMessage_descriptor_;
}

const P2PMessage& P2PMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Proto_2eproto();
  return *default_instance_;
}

P2PMessage* P2PMessage::default_instance_ = NULL;

P2PMessage* P2PMessage::New(::google::protobuf::Arena* arena) const {
  P2PMessage* n = new P2PMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void P2PMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Proto.P2PMessage)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(P2PMessage, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<P2PMessage*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(imessagetype_, port_);

#undef ZR_HELPER_
#undef ZR_

}

bool P2PMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Proto.P2PMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 iMessageType = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &imessagetype_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_iStringLen;
        break;
      }

      // optional int32 iStringLen = 2;
      case 2: {
        if (tag == 16) {
         parse_iStringLen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &istringlen_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Port;
        break;
      }

      // optional uint32 Port = 3;
      case 3: {
        if (tag == 24) {
         parse_Port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Proto.P2PMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Proto.P2PMessage)
  return false;
#undef DO_
}

void P2PMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Proto.P2PMessage)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->imessagetype(), output);
  }

  // optional int32 iStringLen = 2;
  if (this->istringlen() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->istringlen(), output);
  }

  // optional uint32 Port = 3;
  if (this->port() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // @@protoc_insertion_point(serialize_end:Proto.P2PMessage)
}

::google::protobuf::uint8* P2PMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Proto.P2PMessage)
  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->imessagetype(), target);
  }

  // optional int32 iStringLen = 2;
  if (this->istringlen() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->istringlen(), target);
  }

  // optional uint32 Port = 3;
  if (this->port() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->port(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:Proto.P2PMessage)
  return target;
}

int P2PMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:Proto.P2PMessage)
  int total_size = 0;

  // optional int32 iMessageType = 1;
  if (this->imessagetype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->imessagetype());
  }

  // optional int32 iStringLen = 2;
  if (this->istringlen() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->istringlen());
  }

  // optional uint32 Port = 3;
  if (this->port() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Proto.P2PMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const P2PMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const P2PMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Proto.P2PMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Proto.P2PMessage)
    MergeFrom(*source);
  }
}

void P2PMessage::MergeFrom(const P2PMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Proto.P2PMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.imessagetype() != 0) {
    set_imessagetype(from.imessagetype());
  }
  if (from.istringlen() != 0) {
    set_istringlen(from.istringlen());
  }
  if (from.port() != 0) {
    set_port(from.port());
  }
}

void P2PMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Proto.P2PMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PMessage::CopyFrom(const P2PMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Proto.P2PMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PMessage::IsInitialized() const {

  return true;
}

void P2PMessage::Swap(P2PMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void P2PMessage::InternalSwap(P2PMessage* other) {
  std::swap(imessagetype_, other->imessagetype_);
  std::swap(istringlen_, other->istringlen_);
  std::swap(port_, other->port_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata P2PMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PMessage_descriptor_;
  metadata.reflection = P2PMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// P2PMessage

// optional int32 iMessageType = 1;
void P2PMessage::clear_imessagetype() {
  imessagetype_ = 0;
}
 ::google::protobuf::int32 P2PMessage::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iMessageType)
  return imessagetype_;
}
 void P2PMessage::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iMessageType)
}

// optional int32 iStringLen = 2;
void P2PMessage::clear_istringlen() {
  istringlen_ = 0;
}
 ::google::protobuf::int32 P2PMessage::istringlen() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iStringLen)
  return istringlen_;
}
 void P2PMessage::set_istringlen(::google::protobuf::int32 value) {
  
  istringlen_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iStringLen)
}

// optional uint32 Port = 3;
void P2PMessage::clear_port() {
  port_ = 0u;
}
 ::google::protobuf::uint32 P2PMessage::port() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.Port)
  return port_;
}
 void P2PMessage::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.Port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

// @@protoc_insertion_point(global_scope)
