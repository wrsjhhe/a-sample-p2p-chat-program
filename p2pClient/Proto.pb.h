// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Proto.proto

#ifndef PROTOBUF_Proto_2eproto__INCLUDED
#define PROTOBUF_Proto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Proto_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLoginMessageImpl();
void InitDefaultsLoginMessage();
void InitDefaultsLogoutMessageImpl();
void InitDefaultsLogoutMessage();
void InitDefaultsP2PTranslateImpl();
void InitDefaultsP2PTranslate();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
void InitDefaultsUserListNodeImpl();
void InitDefaultsUserListNode();
void InitDefaultsUserListImpl();
void InitDefaultsUserList();
void InitDefaultsServerToClientImpl();
void InitDefaultsServerToClient();
void InitDefaultsP2PMessageImpl();
void InitDefaultsP2PMessage();
inline void InitDefaults() {
  InitDefaultsLoginMessage();
  InitDefaultsLogoutMessage();
  InitDefaultsP2PTranslate();
  InitDefaultsMessage();
  InitDefaultsUserListNode();
  InitDefaultsUserList();
  InitDefaultsServerToClient();
  InitDefaultsP2PMessage();
}
}  // namespace protobuf_Proto_2eproto
namespace Proto {
class LoginMessage;
class LoginMessageDefaultTypeInternal;
extern LoginMessageDefaultTypeInternal _LoginMessage_default_instance_;
class LogoutMessage;
class LogoutMessageDefaultTypeInternal;
extern LogoutMessageDefaultTypeInternal _LogoutMessage_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class P2PMessage;
class P2PMessageDefaultTypeInternal;
extern P2PMessageDefaultTypeInternal _P2PMessage_default_instance_;
class P2PTranslate;
class P2PTranslateDefaultTypeInternal;
extern P2PTranslateDefaultTypeInternal _P2PTranslate_default_instance_;
class ServerToClient;
class ServerToClientDefaultTypeInternal;
extern ServerToClientDefaultTypeInternal _ServerToClient_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserListNode;
class UserListNodeDefaultTypeInternal;
extern UserListNodeDefaultTypeInternal _UserListNode_default_instance_;
}  // namespace Proto
namespace Proto {

// ===================================================================

class LoginMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LoginMessage) */ {
 public:
  LoginMessage();
  virtual ~LoginMessage();

  LoginMessage(const LoginMessage& from);

  inline LoginMessage& operator=(const LoginMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginMessage(LoginMessage&& from) noexcept
    : LoginMessage() {
    *this = ::std::move(from);
  }

  inline LoginMessage& operator=(LoginMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginMessage* internal_default_instance() {
    return reinterpret_cast<const LoginMessage*>(
               &_LoginMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LoginMessage* other);
  friend void swap(LoginMessage& a, LoginMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginMessage& from);
  void MergeFrom(const LoginMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Proto.LoginMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsLoginMessageImpl();
};
// -------------------------------------------------------------------

class LogoutMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LogoutMessage) */ {
 public:
  LogoutMessage();
  virtual ~LogoutMessage();

  LogoutMessage(const LogoutMessage& from);

  inline LogoutMessage& operator=(const LogoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogoutMessage(LogoutMessage&& from) noexcept
    : LogoutMessage() {
    *this = ::std::move(from);
  }

  inline LogoutMessage& operator=(LogoutMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutMessage* internal_default_instance() {
    return reinterpret_cast<const LogoutMessage*>(
               &_LogoutMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LogoutMessage* other);
  friend void swap(LogoutMessage& a, LogoutMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutMessage& from);
  void MergeFrom(const LogoutMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Proto.LogoutMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsLogoutMessageImpl();
};
// -------------------------------------------------------------------

class P2PTranslate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.P2PTranslate) */ {
 public:
  P2PTranslate();
  virtual ~P2PTranslate();

  P2PTranslate(const P2PTranslate& from);

  inline P2PTranslate& operator=(const P2PTranslate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  P2PTranslate(P2PTranslate&& from) noexcept
    : P2PTranslate() {
    *this = ::std::move(from);
  }

  inline P2PTranslate& operator=(P2PTranslate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PTranslate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const P2PTranslate* internal_default_instance() {
    return reinterpret_cast<const P2PTranslate*>(
               &_P2PTranslate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(P2PTranslate* other);
  friend void swap(P2PTranslate& a, P2PTranslate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline P2PTranslate* New() const PROTOBUF_FINAL { return New(NULL); }

  P2PTranslate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const P2PTranslate& from);
  void MergeFrom(const P2PTranslate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(P2PTranslate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:Proto.P2PTranslate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsP2PTranslateImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Proto.LoginMessage loginmember = 2;
  bool has_loginmember() const;
  void clear_loginmember();
  static const int kLoginmemberFieldNumber = 2;
  const ::Proto::LoginMessage& loginmember() const;
  ::Proto::LoginMessage* release_loginmember();
  ::Proto::LoginMessage* mutable_loginmember();
  void set_allocated_loginmember(::Proto::LoginMessage* loginmember);

  // .Proto.LogoutMessage logoutmember = 3;
  bool has_logoutmember() const;
  void clear_logoutmember();
  static const int kLogoutmemberFieldNumber = 3;
  const ::Proto::LogoutMessage& logoutmember() const;
  ::Proto::LogoutMessage* release_logoutmember();
  ::Proto::LogoutMessage* mutable_logoutmember();
  void set_allocated_logoutmember(::Proto::LogoutMessage* logoutmember);

  // .Proto.P2PTranslate translatemessage = 4;
  bool has_translatemessage() const;
  void clear_translatemessage();
  static const int kTranslatemessageFieldNumber = 4;
  const ::Proto::P2PTranslate& translatemessage() const;
  ::Proto::P2PTranslate* release_translatemessage();
  ::Proto::P2PTranslate* mutable_translatemessage();
  void set_allocated_translatemessage(::Proto::P2PTranslate* translatemessage);

  // int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Message)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::LoginMessage* loginmember_;
  ::Proto::LogoutMessage* logoutmember_;
  ::Proto::P2PTranslate* translatemessage_;
  ::google::protobuf::int32 imessagetype_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsMessageImpl();
};
// -------------------------------------------------------------------

class UserListNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.UserListNode) */ {
 public:
  UserListNode();
  virtual ~UserListNode();

  UserListNode(const UserListNode& from);

  inline UserListNode& operator=(const UserListNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserListNode(UserListNode&& from) noexcept
    : UserListNode() {
    *this = ::std::move(from);
  }

  inline UserListNode& operator=(UserListNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserListNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserListNode* internal_default_instance() {
    return reinterpret_cast<const UserListNode*>(
               &_UserListNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UserListNode* other);
  friend void swap(UserListNode& a, UserListNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserListNode* New() const PROTOBUF_FINAL { return New(NULL); }

  UserListNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserListNode& from);
  void MergeFrom(const UserListNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserListNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userName = 1;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // uint32 ip = 2;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  ::google::protobuf::uint32 ip() const;
  void set_ip(::google::protobuf::uint32 value);

  // uint32 port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.UserListNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsUserListNodeImpl();
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.UserList) */ {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(UserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UserList* other);
  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserList* New() const PROTOBUF_FINAL { return New(NULL); }

  UserList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.UserListNode userListNode = 1;
  int userlistnode_size() const;
  void clear_userlistnode();
  static const int kUserListNodeFieldNumber = 1;
  const ::Proto::UserListNode& userlistnode(int index) const;
  ::Proto::UserListNode* mutable_userlistnode(int index);
  ::Proto::UserListNode* add_userlistnode();
  ::google::protobuf::RepeatedPtrField< ::Proto::UserListNode >*
      mutable_userlistnode();
  const ::google::protobuf::RepeatedPtrField< ::Proto::UserListNode >&
      userlistnode() const;

  // @@protoc_insertion_point(class_scope:Proto.UserList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Proto::UserListNode > userlistnode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsUserListImpl();
};
// -------------------------------------------------------------------

class ServerToClient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.ServerToClient) */ {
 public:
  ServerToClient();
  virtual ~ServerToClient();

  ServerToClient(const ServerToClient& from);

  inline ServerToClient& operator=(const ServerToClient& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerToClient(ServerToClient&& from) noexcept
    : ServerToClient() {
    *this = ::std::move(from);
  }

  inline ServerToClient& operator=(ServerToClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerToClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerToClient* internal_default_instance() {
    return reinterpret_cast<const ServerToClient*>(
               &_ServerToClient_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ServerToClient* other);
  friend void swap(ServerToClient& a, ServerToClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerToClient* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerToClient* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerToClient& from);
  void MergeFrom(const ServerToClient& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerToClient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Proto.UserListNode user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::Proto::UserListNode& user() const;
  ::Proto::UserListNode* release_user();
  ::Proto::UserListNode* mutable_user();
  void set_allocated_user(::Proto::UserListNode* user);

  // int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.ServerToClient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::UserListNode* user_;
  ::google::protobuf::int32 imessagetype_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsServerToClientImpl();
};
// -------------------------------------------------------------------

class P2PMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.P2PMessage) */ {
 public:
  P2PMessage();
  virtual ~P2PMessage();

  P2PMessage(const P2PMessage& from);

  inline P2PMessage& operator=(const P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  P2PMessage(P2PMessage&& from) noexcept
    : P2PMessage() {
    *this = ::std::move(from);
  }

  inline P2PMessage& operator=(P2PMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const P2PMessage* internal_default_instance() {
    return reinterpret_cast<const P2PMessage*>(
               &_P2PMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(P2PMessage* other);
  friend void swap(P2PMessage& a, P2PMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline P2PMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  P2PMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const P2PMessage& from);
  void MergeFrom(const P2PMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(P2PMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 iMessageType = 1;
  void clear_imessagetype();
  static const int kIMessageTypeFieldNumber = 1;
  ::google::protobuf::int32 imessagetype() const;
  void set_imessagetype(::google::protobuf::int32 value);

  // int32 iStringLen = 2;
  void clear_istringlen();
  static const int kIStringLenFieldNumber = 2;
  ::google::protobuf::int32 istringlen() const;
  void set_istringlen(::google::protobuf::int32 value);

  // uint32 Port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Proto.P2PMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 imessagetype_;
  ::google::protobuf::int32 istringlen_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_Proto_2eproto::TableStruct;
  friend void ::protobuf_Proto_2eproto::InitDefaultsP2PMessageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginMessage

// string userName = 1;
inline void LoginMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.userName)
  return username_.GetNoArena();
}
inline void LoginMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.userName)
}
#if LANG_CXX11
inline void LoginMessage::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.LoginMessage.userName)
}
#endif
inline void LoginMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.userName)
}
inline void LoginMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.userName)
}
inline ::std::string* LoginMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.userName)
}

// string password = 2;
inline void LoginMessage::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginMessage::password() const {
  // @@protoc_insertion_point(field_get:Proto.LoginMessage.password)
  return password_.GetNoArena();
}
inline void LoginMessage::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginMessage.password)
}
#if LANG_CXX11
inline void LoginMessage::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.LoginMessage.password)
}
#endif
inline void LoginMessage::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginMessage.password)
}
inline void LoginMessage::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginMessage.password)
}
inline ::std::string* LoginMessage::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginMessage.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginMessage::release_password() {
  // @@protoc_insertion_point(field_release:Proto.LoginMessage.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginMessage::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginMessage.password)
}

// -------------------------------------------------------------------

// LogoutMessage

// string userName = 1;
inline void LogoutMessage::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogoutMessage::username() const {
  // @@protoc_insertion_point(field_get:Proto.LogoutMessage.userName)
  return username_.GetNoArena();
}
inline void LogoutMessage::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LogoutMessage.userName)
}
#if LANG_CXX11
inline void LogoutMessage::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.LogoutMessage.userName)
}
#endif
inline void LogoutMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LogoutMessage.userName)
}
inline void LogoutMessage::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LogoutMessage.userName)
}
inline ::std::string* LogoutMessage::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LogoutMessage.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogoutMessage::release_username() {
  // @@protoc_insertion_point(field_release:Proto.LogoutMessage.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutMessage::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.LogoutMessage.userName)
}

// -------------------------------------------------------------------

// P2PTranslate

// string userName = 1;
inline void P2PTranslate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& P2PTranslate::username() const {
  // @@protoc_insertion_point(field_get:Proto.P2PTranslate.userName)
  return username_.GetNoArena();
}
inline void P2PTranslate::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.P2PTranslate.userName)
}
#if LANG_CXX11
inline void P2PTranslate::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.P2PTranslate.userName)
}
#endif
inline void P2PTranslate::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.P2PTranslate.userName)
}
inline void P2PTranslate::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.P2PTranslate.userName)
}
inline ::std::string* P2PTranslate::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.P2PTranslate.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* P2PTranslate::release_username() {
  // @@protoc_insertion_point(field_release:Proto.P2PTranslate.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void P2PTranslate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.P2PTranslate.userName)
}

// -------------------------------------------------------------------

// Message

// int32 iMessageType = 1;
inline void Message::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 Message::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.Message.iMessageType)
  return imessagetype_;
}
inline void Message::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Message.iMessageType)
}

// .Proto.LoginMessage loginmember = 2;
inline bool Message::has_loginmember() const {
  return this != internal_default_instance() && loginmember_ != NULL;
}
inline void Message::clear_loginmember() {
  if (GetArenaNoVirtual() == NULL && loginmember_ != NULL) {
    delete loginmember_;
  }
  loginmember_ = NULL;
}
inline const ::Proto::LoginMessage& Message::loginmember() const {
  const ::Proto::LoginMessage* p = loginmember_;
  // @@protoc_insertion_point(field_get:Proto.Message.loginmember)
  return p != NULL ? *p : *reinterpret_cast<const ::Proto::LoginMessage*>(
      &::Proto::_LoginMessage_default_instance_);
}
inline ::Proto::LoginMessage* Message::release_loginmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.loginmember)
  
  ::Proto::LoginMessage* temp = loginmember_;
  loginmember_ = NULL;
  return temp;
}
inline ::Proto::LoginMessage* Message::mutable_loginmember() {
  
  if (loginmember_ == NULL) {
    loginmember_ = new ::Proto::LoginMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.loginmember)
  return loginmember_;
}
inline void Message::set_allocated_loginmember(::Proto::LoginMessage* loginmember) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete loginmember_;
  }
  if (loginmember) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      loginmember = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, loginmember, submessage_arena);
    }
    
  } else {
    
  }
  loginmember_ = loginmember;
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.loginmember)
}

// .Proto.LogoutMessage logoutmember = 3;
inline bool Message::has_logoutmember() const {
  return this != internal_default_instance() && logoutmember_ != NULL;
}
inline void Message::clear_logoutmember() {
  if (GetArenaNoVirtual() == NULL && logoutmember_ != NULL) {
    delete logoutmember_;
  }
  logoutmember_ = NULL;
}
inline const ::Proto::LogoutMessage& Message::logoutmember() const {
  const ::Proto::LogoutMessage* p = logoutmember_;
  // @@protoc_insertion_point(field_get:Proto.Message.logoutmember)
  return p != NULL ? *p : *reinterpret_cast<const ::Proto::LogoutMessage*>(
      &::Proto::_LogoutMessage_default_instance_);
}
inline ::Proto::LogoutMessage* Message::release_logoutmember() {
  // @@protoc_insertion_point(field_release:Proto.Message.logoutmember)
  
  ::Proto::LogoutMessage* temp = logoutmember_;
  logoutmember_ = NULL;
  return temp;
}
inline ::Proto::LogoutMessage* Message::mutable_logoutmember() {
  
  if (logoutmember_ == NULL) {
    logoutmember_ = new ::Proto::LogoutMessage;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.logoutmember)
  return logoutmember_;
}
inline void Message::set_allocated_logoutmember(::Proto::LogoutMessage* logoutmember) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete logoutmember_;
  }
  if (logoutmember) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      logoutmember = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, logoutmember, submessage_arena);
    }
    
  } else {
    
  }
  logoutmember_ = logoutmember;
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.logoutmember)
}

// .Proto.P2PTranslate translatemessage = 4;
inline bool Message::has_translatemessage() const {
  return this != internal_default_instance() && translatemessage_ != NULL;
}
inline void Message::clear_translatemessage() {
  if (GetArenaNoVirtual() == NULL && translatemessage_ != NULL) {
    delete translatemessage_;
  }
  translatemessage_ = NULL;
}
inline const ::Proto::P2PTranslate& Message::translatemessage() const {
  const ::Proto::P2PTranslate* p = translatemessage_;
  // @@protoc_insertion_point(field_get:Proto.Message.translatemessage)
  return p != NULL ? *p : *reinterpret_cast<const ::Proto::P2PTranslate*>(
      &::Proto::_P2PTranslate_default_instance_);
}
inline ::Proto::P2PTranslate* Message::release_translatemessage() {
  // @@protoc_insertion_point(field_release:Proto.Message.translatemessage)
  
  ::Proto::P2PTranslate* temp = translatemessage_;
  translatemessage_ = NULL;
  return temp;
}
inline ::Proto::P2PTranslate* Message::mutable_translatemessage() {
  
  if (translatemessage_ == NULL) {
    translatemessage_ = new ::Proto::P2PTranslate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Message.translatemessage)
  return translatemessage_;
}
inline void Message::set_allocated_translatemessage(::Proto::P2PTranslate* translatemessage) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete translatemessage_;
  }
  if (translatemessage) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      translatemessage = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, translatemessage, submessage_arena);
    }
    
  } else {
    
  }
  translatemessage_ = translatemessage;
  // @@protoc_insertion_point(field_set_allocated:Proto.Message.translatemessage)
}

// -------------------------------------------------------------------

// UserListNode

// string userName = 1;
inline void UserListNode::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserListNode::username() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.userName)
  return username_.GetNoArena();
}
inline void UserListNode::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.UserListNode.userName)
}
#if LANG_CXX11
inline void UserListNode::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Proto.UserListNode.userName)
}
#endif
inline void UserListNode::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.UserListNode.userName)
}
inline void UserListNode::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.UserListNode.userName)
}
inline ::std::string* UserListNode::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Proto.UserListNode.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserListNode::release_username() {
  // @@protoc_insertion_point(field_release:Proto.UserListNode.userName)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserListNode::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Proto.UserListNode.userName)
}

// uint32 ip = 2;
inline void UserListNode::clear_ip() {
  ip_ = 0u;
}
inline ::google::protobuf::uint32 UserListNode::ip() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.ip)
  return ip_;
}
inline void UserListNode::set_ip(::google::protobuf::uint32 value) {
  
  ip_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.ip)
}

// uint32 port = 3;
inline void UserListNode::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 UserListNode::port() const {
  // @@protoc_insertion_point(field_get:Proto.UserListNode.port)
  return port_;
}
inline void UserListNode::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.UserListNode.port)
}

// -------------------------------------------------------------------

// UserList

// repeated .Proto.UserListNode userListNode = 1;
inline int UserList::userlistnode_size() const {
  return userlistnode_.size();
}
inline void UserList::clear_userlistnode() {
  userlistnode_.Clear();
}
inline const ::Proto::UserListNode& UserList::userlistnode(int index) const {
  // @@protoc_insertion_point(field_get:Proto.UserList.userListNode)
  return userlistnode_.Get(index);
}
inline ::Proto::UserListNode* UserList::mutable_userlistnode(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.UserList.userListNode)
  return userlistnode_.Mutable(index);
}
inline ::Proto::UserListNode* UserList::add_userlistnode() {
  // @@protoc_insertion_point(field_add:Proto.UserList.userListNode)
  return userlistnode_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::UserListNode >*
UserList::mutable_userlistnode() {
  // @@protoc_insertion_point(field_mutable_list:Proto.UserList.userListNode)
  return &userlistnode_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::UserListNode >&
UserList::userlistnode() const {
  // @@protoc_insertion_point(field_list:Proto.UserList.userListNode)
  return userlistnode_;
}

// -------------------------------------------------------------------

// ServerToClient

// int32 iMessageType = 1;
inline void ServerToClient::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 ServerToClient::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.iMessageType)
  return imessagetype_;
}
inline void ServerToClient::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.ServerToClient.iMessageType)
}

// .Proto.UserListNode user = 2;
inline bool ServerToClient::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void ServerToClient::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) {
    delete user_;
  }
  user_ = NULL;
}
inline const ::Proto::UserListNode& ServerToClient::user() const {
  const ::Proto::UserListNode* p = user_;
  // @@protoc_insertion_point(field_get:Proto.ServerToClient.user)
  return p != NULL ? *p : *reinterpret_cast<const ::Proto::UserListNode*>(
      &::Proto::_UserListNode_default_instance_);
}
inline ::Proto::UserListNode* ServerToClient::release_user() {
  // @@protoc_insertion_point(field_release:Proto.ServerToClient.user)
  
  ::Proto::UserListNode* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::Proto::UserListNode* ServerToClient::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::Proto::UserListNode;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerToClient.user)
  return user_;
}
inline void ServerToClient::set_allocated_user(::Proto::UserListNode* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_;
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerToClient.user)
}

// -------------------------------------------------------------------

// P2PMessage

// int32 iMessageType = 1;
inline void P2PMessage::clear_imessagetype() {
  imessagetype_ = 0;
}
inline ::google::protobuf::int32 P2PMessage::imessagetype() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iMessageType)
  return imessagetype_;
}
inline void P2PMessage::set_imessagetype(::google::protobuf::int32 value) {
  
  imessagetype_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iMessageType)
}

// int32 iStringLen = 2;
inline void P2PMessage::clear_istringlen() {
  istringlen_ = 0;
}
inline ::google::protobuf::int32 P2PMessage::istringlen() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.iStringLen)
  return istringlen_;
}
inline void P2PMessage::set_istringlen(::google::protobuf::int32 value) {
  
  istringlen_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.iStringLen)
}

// uint32 Port = 3;
inline void P2PMessage::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 P2PMessage::port() const {
  // @@protoc_insertion_point(field_get:Proto.P2PMessage.Port)
  return port_;
}
inline void P2PMessage::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:Proto.P2PMessage.Port)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Proto_2eproto__INCLUDED
